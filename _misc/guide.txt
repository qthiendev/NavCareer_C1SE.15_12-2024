-- Route
-- note that if any route return status 500 mean server is error, ask backend dev!!!
-------------------------------------------------------------------------------------------------------------------------------
GET:    /authz/student -> student check
GET:    /authz/esp -> education service provider check
GET:    /authz/admin -> adim check
-- if if respone status 403, mean user is not type of what you want, if it respone status 200, it okay
-- Note that this is for frontend prcess, backend must inclue middleware to at least 2nd layer route
-------------------------------------------------------------------------------------------------------------------------------
POST:   /auth/signin    |body{account, password}|                   
-> for sign in, 200 is success, 203 is failed, 201 is already signed in 

POST:   /auth/signout   |[None]|                                    
-> for sign out, 200 is success, 203 is failed

POST:   /auth/signup    |body{account, password, email, authz_id}|  
-> for sign up, 200 is success, 203 is failed, 201 is already exist

POST:   /auth/update    |body{new_account, current_password, new_password, new_identifier_email, new_authz_id}| 
-> for update auth info, 200 is success, 203 is failed

GET:    /auth/status    |[None]|
-> this one usally return 203 with 'sign_in_status' as TRUE or FALSE. TRUE is signed in, FALSE is NOT signed in

-------------------------------------------------------------------------------------------------------------------------------
POST:   /profile/create ||
GET:    /profile/read   ||
POST:   /profile/update ||
DELETE: /profile/delete ||

POST:   /course/create
GET:    /course/read
POST:   /course/update 
DELETE: /course/delete 

-------------------------------------------------------------------------------------------------------------------------------
query data base
---------------------

1. Create procedure first, must include @secret_key

ex:
if object_id('ProcedureName', 'P') is not null drop procedure ProcedureName;
go
create procedure ProcedureName
	@secret_key nvarchar(max),
    [any index]
as
begin
    EncryptByPassPhrase(@secret_key, [index]) -> this will encode the data
    DecryptByPassPhrase(@secret_key, [index]) -> this will decode the data
end
go
---------------------

2. in backend, note that service(model) and controller must in the same folder

//service.js | must include @secret_key in query but dont add it to params, query service will make it for you
const ncdb = require('ncdbService.js path');
const serviceName = (userType, [any index]) {
    try {
        const queryString = 'EXECUTE ProcedureName @secret_key, [any index]';
        const params = {params for index only};
        const result = ncdb.query(userType, queryString, params);

        return result; -> result is now record set, return result[0] if take only one row, true false by your logic, NOTE IT
    } catch(err) {
        throw new Error(); -> handel error here
    }
}
module.export = {serviceName};

//controller.js | If not require sign in, default userType is 'GST', and if it signed in, take it from session
const {serviceName} = require('./serviceName')
const controllerName = {
    try {
        const { aid, role } = req.session; //aid is auth_id, role is userType
        const [index] = take from body or query or smthing else, base on you
        const result = serviceName(role, [index]); -> use this if require sign in
        const result = serviceName('GST', [index]); -> use this if not require sign in

        console.log('log to traking'); - > any status code have it own log, just log it out to handle
        //status code: 200 for success, 203 for failed, 201 also failed but when user already do somthing
        res.status(status_code).json({
            any_name: any_data -> what you want to respone, backend and frontend must work together
        });
    } catch(err) {
        console.error(err);
        res.status(500).json({
            this is when controller error that cannot handle at this time
        });
    }
}
module.export = {controllerName};

//router.js
const express = require("express");
const router = express.Router();

const authMiddlware = require('../middlewares/authentication');
const authzMiddlware = require('../middlewares/authorization');

const {controllerName} = require('controller path');

//force user sign in, get or post base on u
router.get('/2nd_route_name', authMiddlware.isSignedIn, controllerName);

//force user not sign in, get or post base on u
router.get('/2nd_route_name', authMiddlware.isNotSignedIn, controllerName);

//force user be specific role, get or post base on u
router.get('/2nd_route_name', authMiddlware.isSignedIn, authzMiddlware.roleName, controllerName);
-> in there authzMiddlware.roleName find in ../middlewares/authorization

module.exports = router;

//mainRouter.js
const express = require('express');
const router = express.Router();

// Import routes
const router_name = require('router path');


// Use routes
router.use('/1st_route_name', router_name);

module.exports = router;